Here is the code so far:

.gitignore:
```
node_modules

.myignore
.venv
```

.gitmodules:
```
[submodule "lib/forge-std"]
	path = lib/forge-std
	url = https://github.com/foundry-rs/forge-std
[submodule "lib/account-abstraction"]
	path = lib/account-abstraction
	url = https://github.com/eth-infinitism/account-abstraction
[submodule "lib/openzeppelin-contracts"]
	path = lib/openzeppelin-contracts
	url = https://github.com/OpenZeppelin/openzeppelin-contracts

```

docker-compose.yml:
```
services:
  anvil:
    image: ghcr.io/foundry-rs/foundry:latest
    user: "root"  # Use root user which should exist in all containers
    command: ["anvil","--host","0.0.0.0","-m","auto"]
    ports:
      - "8545:8545"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_PASSWORD: pass
    ports:
      - "5432:5432"

```

eligibility.r1cs:
```
file content
```

eligibility.sym:
```
1,2,0,main.msgHash
2,3,0,main.r
3,4,0,main.s
4,5,0,main.pubKey[0]
5,6,0,main.pubKey[1]
6,7,0,main.eligibility
7,2,1,main.ecdsa.msg
8,3,1,main.ecdsa.r
9,4,1,main.ecdsa.s
10,5,1,main.ecdsa.P[0]
11,6,1,main.ecdsa.P[1]
12,1,1,main.ecdsa.valid
13,1,0,main.valid

```

eligibility.wasm:
```
file content
```

foundry.toml:
```
[profile.default]
src   = "contracts"
out   = "out"
libs  = ["lib"]

[invariant]
maxRuns = 500    # default is 2000


[fuzz]
runs = 256        # default for fuzz tests

```

init.sh:
```
# init.sh – one‑shot repo bootstrap
set -e
d=(contracts circuits packages/frontend packages/backend .github/workflows)
for dir in "${d[@]}"; do mkdir -p "$dir"; done

cat > docker-compose.yml <<'YAML'
version: "3.9"
services:
  anvil: {image: ghcr.io/foundry-rs/foundry, command: ["anvil", "-m", "auto"], ports: ["8545:8545"]}
  redis: {image: redis:7-alpine, ports: ["6379:6379"]}
  db:    {image: postgres:16-alpine, environment: {POSTGRES_PASSWORD: pass}, ports: ["5432:5432"]}
YAML

cat > .github/workflows/ci.yml <<'YAML'
name: CI
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: foundry-rs/foundry-toolchain@v1
    - run: forge test
    - uses: actions/setup-node@v4
      with: {node-version: 20}
    - run: npm i -g yarn
    - run: yarn install --immutable
    - run: yarn --cwd packages/frontend type-check
    - run: npx circom circuits/eligibility.circom --r1cs --wasm --sym
YAML

cat > contracts/WalletFactory.sol <<'SOL'
pragma solidity ^0.8.24;
interface IVerifier{function verify(bytes calldata,bytes calldata)external view returns(bool);}
contract WalletFactory{
    IVerifier immutable v; mapping(address=>bool)public minted;
    event WalletMinted(address indexed user,address wallet);
    constructor(IVerifier _v){v=_v;}
    function mintWallet(bytes calldata proof,address pubKey) external returns(address){
        require(!minted[msg.sender],"dup");
        require(v.verify(proof,abi.encode(pubKey)),"bad");
        bytes20 salt=bytes20(pubKey);
        address wallet=address(uint160(uint(keccak256(abi.encodePacked(bytes1(0xff),address(this),salt,keccak256(type(Proxy).creationCode))))));
        new Proxy{salt:bytes32(salt)}(pubKey);
        minted[msg.sender]=true;
        emit WalletMinted(msg.sender,wallet);
        return wallet;
    }
}
contract Proxy{
    constructor(address owner){
        assembly{ sstore(0x00,owner) }
    }
}
SOL

cat > contracts/ElectionManager.sol <<'SOL'
pragma solidity ^0.8.24;
interface IMACI{function publishMessage(bytes calldata)external;}
contract ElectionManager{
    IMACI immutable maci;
    event ElectionCreated(uint id,bytes32 meta);
    struct E{uint start;uint end;}
    mapping(uint=>E) public elections; uint public nextId;
    constructor(IMACI _m){maci=_m;}
    function createElection(bytes32 meta) external{ elections[nextId]=E(block.number,block.number+7200); emit ElectionCreated(nextId++,meta);}
    function enqueueMessage(uint vote,uint nonce,bytes calldata vcProof) external{ require(block.number<=elections[0].end,"closed"); maci.publishMessage(abi.encode(msg.sender,vote,nonce,vcProof));}
}
SOL

cat > circuits/eligibility.circom <<'CIR'
template Eligibility(){
  signal input eligibility;
  signal input pubKey[2];
  signal output valid;
  valid <== 1;
  eligibility === 1;
}
component main = Eligibility();
CIR

cat > packages/backend/main.py <<'PY'
from fastapi import FastAPI,Request,HTTPException
from jose import jwt
import httpx,os
app=FastAPI()
IDP=os.getenv("IDP_BASE","https://idp.example")
CID,RED=os.getenv("CID"),os.getenv("REDIR")
@app.get("/auth/initiate")
async def init():
    return {"url":f"{IDP}/auth?client_id={CID}&redirect_uri={RED}&scope=openid"}
@app.get("/auth/callback")
async def cb(code:str):
    async with httpx.AsyncClient() as c:
        r=await c.post(f"{IDP}/token",data={"code":code,"client_id":CID,"redirect_uri":RED})
    tok=r.json()["id_token"]
    try: jwt.decode(tok,options={"verify_signature":False})
    except: raise HTTPException(400,"bad token")
    return tok
PY

cat > packages/frontend/package.json <<'JSON'
{ "name":"frontend","private":true,"scripts":{"dev":"next dev","type-check":"tsc --noEmit"} }
JSON
yarn --cwd packages/frontend init -y >/dev/null
printf 'import Link from"next/link";export default function Auth(){return <Link href="/api/auth/initiate">Login</Link>}' > packages/frontend/pages/auth.tsx

echo 'SUBDIRS DONE'

```

remappings.txt:
```
forge-std/=lib/forge-std/src/
@account-abstraction/=lib/account-abstraction/
@openzeppelin/=lib/openzeppelin-contracts/

```

.github/workflows/ci.yml:
```
# .github/workflows/ci.yml
name: CI
on:
  - push
  - pull_request

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Foundry toolchain
        uses: foundry-rs/foundry-toolchain@v1

      - name: Run unit tests
        run: forge test

      - name: Generate gas report
        run: forge test --gas-report > gas-report.txt

      - name: Upload gas report artifact
        uses: actions/upload-artifact@v3
        with:
          name: gas-report
          path: gas-report.txt

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install frontend dependencies
        run: npm i -g yarn

      - name: Type‑check frontend
        run: yarn install --immutable && yarn --cwd packages/frontend type-check

      - name: Compile Circom circuits
        run: npx circom circuits/eligibility.circom --r1cs --wasm --sym

```

.github/workflows/security.yml:
```
# .github/workflows/security.yml
jobs:
  security:
    runs-on: ubuntu-latest
    steps:
      - uses: trailofbits/slither-action@v1
        with:
          args: --no-compile

```

circuits/eligibility.circom:
```
// circuits/eligibility.circom

// Stubbed verifier
template PoseidonSigVerifier() {
    signal input msg;
    signal input r;
    signal input s;
    signal input P[2];
    signal output valid;
    valid <== 1;
}

// Main eligibility check
template Eligibility() {
    // public input: JWT header+payload hash
    signal input msgHash;
    // private ECDSA signature parts
    signal input r;
    signal input s;
    // public key (x, y)
    signal input pubKey[2];
    // eligibility flag from JWT payload
    signal input eligibility;

    // verify signature (stub)
    component ecdsa = PoseidonSigVerifier();
    ecdsa.msg    <== msgHash;
    ecdsa.r      <== r;
    ecdsa.s      <== s;
    ecdsa.P[0]   <== pubKey[0];
    ecdsa.P[1]   <== pubKey[1];

    // expose the stub’s “valid” bit
    signal output valid;
    valid <== ecdsa.valid;

    // enforce eligibility == 1
    eligibility === 1;
}

// single entry‑point
component main = Eligibility();

```

circuits/tally.circom:
```
include "poseidon.circom";
template Tally(N){
  signal input c1_x[N], c1_y[N], c2_x[N], c2_y[N];
  signal output tallyA;
  signal output tallyB;
  // for i in 0..N:
  //   decrypt(c1,c2) → bit
  //   bit*(1−bit) == 0
  //   tallyA += bit; tallyB += 1−bit
}
component main = Tally(/** batch size, e.g. 512 **/);

```

contracts/ElectionManager.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./TallyVerifier.sol";

interface IMACI {
    function publishMessage(bytes calldata) external;
}

contract ElectionManager {
    IMACI public immutable maci;
    TallyVerifier public tallyVerifier;
    bool public tallied;

    event ElectionCreated(uint id, bytes32 meta);
    event Tally(uint256 A, uint256 B);

    struct E {
        uint start;
        uint end;
    }
    mapping(uint => E) public elections;
    uint public nextId;

    constructor(IMACI _m) {
        maci = _m;
        tallyVerifier = TallyVerifier(address(0)); // wire up real verifier later
    }

    function createElection(bytes32 meta) external {
        elections[nextId] = E(block.number, block.number + 7200);
        emit ElectionCreated(nextId, meta);
        nextId++;
    }

    function enqueueMessage(
        uint vote,
        uint nonce,
        bytes calldata vcProof
    ) external {
        require(block.number <= elections[0].end, "closed");
        maci.publishMessage(abi.encode(msg.sender, vote, nonce, vcProof));
    }

    function tallyVotes(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata pubSignals
    ) external {
        require(!tallied, "already tallied");
        require(
            tallyVerifier.verifyProof(a, b, c, pubSignals),
            "invalid tally proof"
        );
        (uint256 A, uint256 B) = (pubSignals[0], pubSignals[1]);
        emit Tally(A, B);
        tallied = true;
    }
}

```

contracts/SmartWallet.sol:
```
// contracts/SmartWallet.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@account-abstraction/contracts/core/BaseAccount.sol";
import "@account-abstraction/contracts/interfaces/IEntryPoint.sol";
import "@account-abstraction/contracts/interfaces/PackedUserOperation.sol";
import "@account-abstraction/contracts/core/Helpers.sol";

contract SmartWallet is BaseAccount {
    address public owner;
    IEntryPoint private immutable _entryPoint;

    constructor(IEntryPoint entryPoint_, address owner_) {
        _entryPoint = entryPoint_;
        owner        = owner_;
    }

    /// @notice Required by BaseAccount
    function entryPoint() public view override returns (IEntryPoint) {
        return _entryPoint;
    }

    /// @notice Hook called by BaseAccount.validateUserOp(...)
    /// @dev Must return 0 if valid, SIG_VALIDATION_FAILED otherwise.
    function _validateSignature(
        PackedUserOperation calldata userOp,
        bytes32 userOpHash
    ) internal view override returns (uint256) {
        // we trust the entryPoint to have correctly hashed the UserOp
        if (!_isValidSignature(userOpHash, userOp.signature)) {
            return SIG_VALIDATION_FAILED;
        }
        return 0;
    }

    /// @dev Simple ECDSA check for `owner`
    function _isValidSignature(bytes32 hash, bytes memory signature)
        internal
        view
        returns (bool)
    {
        (uint8 v, bytes32 r, bytes32 s) = abi.decode(signature, (uint8, bytes32, bytes32));
        address recovered = ecrecover(hash, v, r, s);
        return recovered == owner;
    }

    receive() external payable {}
}

```

contracts/TallyVerifier.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Verifier.sol";

contract TallyVerifier is Verifier {}

```

contracts/Verifier.sol:
```
// contracts/Verifier.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

contract Verifier {
    // snarkjs will fill in the actual VerifyingKey and proof checks
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[] memory input
    ) external view virtual returns (bool) {
        // AUTO‑GENERATED: snarkjs exportSolidityVerifier
        return true;
    }
}

```

contracts/WalletFactory.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "./Verifier.sol";
import "./SmartWallet.sol";
import "@account-abstraction/contracts/core/EntryPoint.sol";

contract WalletFactory {
    EntryPoint public immutable entryPoint;
    Verifier   public immutable verifier;
    mapping(address => address) public walletOf;

    event WalletMinted(address indexed owner, address indexed wallet);

    constructor(EntryPoint _entryPoint, Verifier _verifier) {
        entryPoint = _entryPoint;
        verifier   = _verifier;
    }

    /**
     * @notice Mint a new ERC‑4337 SmartWallet for `owner`, after proving eligibility.
     * @param a    snarkjs proof parameter 'a'
     * @param b    snarkjs proof parameter 'b'
     * @param c    snarkjs proof parameter 'c'
     * @param pubSignals the public inputs array: [ msgHash, pubKeyX, pubKeyY, … ]
     * @param owner the EOAccount that will own the new SmartWallet
     * @return wallet the address of the newly deployed SmartWallet
     */
    function mintWallet(
        uint256[2] calldata a,
        uint256[2][2] calldata b,
        uint256[2] calldata c,
        uint256[] calldata pubSignals,
        address owner
    ) external returns (address wallet) {
        require(walletOf[msg.sender] == address(0), "Factory: already minted");

        // Verify zero‑knowledge proof of eligibility (JWT sig + eligibility==1)
        require(
            verifier.verifyProof(a, b, c, pubSignals),
            "Factory: invalid proof"
        );

        // Deploy via CREATE2 so address = keccak256( 0xff, factory, salt, codeHash )
        bytes32 salt = keccak256(abi.encodePacked(owner, msg.sender));
        wallet = address(new SmartWallet{salt: salt}(entryPoint, owner));

        walletOf[msg.sender] = wallet;
        emit WalletMinted(owner, wallet);
    }
}

```

script/DeployFactory.s.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import "forge-std/Script.sol";
import "../contracts/Verifier.sol";
import "../contracts/WalletFactory.sol";
import "@account-abstraction/contracts/core/EntryPoint.sol";

contract VerifierStub is Verifier {
    function verifyProof(
        uint256[2] memory,
        uint256[2][2] memory,
        uint256[2] memory,
        uint256[] memory
    ) external pure override returns (bool) {
        return true;
    }
}

contract DeployFactory is Script {
    function run() external {
        vm.startBroadcast();
        VerifierStub vs = new VerifierStub();
        WalletFactory factory = new WalletFactory(
            EntryPoint(payable(address(0))),
            vs
        );
        console.log("Factory deployed at:", address(factory));
        vm.stopBroadcast();
    }
}

```

scripts/run_smoke.sh:
```
mkdir -p scripts
cat > scripts/run_smoke.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

# 1) Start Anvil with a known mnemonic
killall anvil 2>/dev/null || true
anvil --host 0.0.0.0 \
      --port 8545 \
      -m "test test test test test test test test test test test junk" \
      --silent &
ANVIL_PID=$!
sleep 1

# 2) Funded private‑key for account[0]
PK=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
ADDR=0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
echo "→ Using funded account $ADDR"

# 3) Deploy factory
forge script script/DeployFactory.s.sol:DeployFactory \
  --rpc-url http://127.0.0.1:8545 \
  --private-key $PK \
  --broadcast -q

FACTORY_ADDRESS=$(jq -r '.transactions[-1].contractAddress' \
  broadcast/DeployFactory.s.sol/31337/run-latest.json)
echo "→ Factory deployed at $FACTORY_ADDRESS"

# 4) Run the smoke test
BACKEND=http://127.0.0.1:8000 \
FACTORY_ADDRESS=$FACTORY_ADDRESS \
PRIVATE_KEY=$PK \
python3 scripts/smoke_auth_to_mint.py

# 5) Tear down Anvil
kill $ANVIL_PID
EOF

```

scripts/smoke_auth_to_mint.py:
```
#!/usr/bin/env python3
import os
import sys
import requests
from web3 import Web3
from eth_account import Account

# ── CONFIG ───────────────────────────────────────────────────────
BACKEND = os.getenv("BACKEND", "http://127.0.0.1:8000")
ANVIL   = os.getenv("ANVIL",   "http://127.0.0.1:8545")
FACTORY_ADDRESS = os.getenv("FACTORY_ADDRESS")
if not FACTORY_ADDRESS:
    print("❌ please set FACTORY_ADDRESS")
    sys.exit(1)
try:
    FACTORY_ADDRESS = Web3.to_checksum_address(FACTORY_ADDRESS)
except Exception:
    FACTORY_ADDRESS = Web3.toChecksumAddress(FACTORY_ADDRESS)  # older versions
print(f"Using factory address (checksummed): {FACTORY_ADDRESS}")

# Use Anvil's default first private key so it's funded out of the box
PRIVATE_KEY = os.getenv("PRIVATE_KEY",
    "0x59c6995e998f97a5a0044966f0945382fdbd5656656b4e3934e658449e610ba3"
)

FACTORY_ABI = [
    {
        "inputs":[
            {"internalType":"uint256[2]","name":"a","type":"uint256[2]"},
            {"internalType":"uint256[2][2]","name":"b","type":"uint256[2][2]"},
            {"internalType":"uint256[2]","name":"c","type":"uint256[2]"},
            {"internalType":"uint256[]","name":"pubSignals","type":"uint256[]"},
            {"internalType":"address","name":"owner","type":"address"}
        ],
        "name":"mintWallet",
        "outputs":[{"internalType":"address","name":"wallet","type":"address"}],
        "stateMutability":"nonpayable","type":"function"
    },
    {
        "anonymous":False,
        "inputs":[
            {"indexed":True,"internalType":"address","name":"owner","type":"address"},
            {"indexed":True,"internalType":"address","name":"wallet","type":"address"}
        ],
        "name":"WalletMinted","type":"event"
    }
]
# ── END CONFIG ───────────────────────────────────────────────────

# 1. Auth flow: fetch the initiate URL without following redirects
init_url = f"{BACKEND}/auth/initiate"
print(f"→ GET {init_url}")
r = requests.get(init_url, allow_redirects=False, timeout=3)
print("  status:", r.status_code)
if r.status_code in (301,302,303,307,308):
    print("  redirect →", r.headers.get("location"))
else:
    print("❌ expected a redirect; got body:", r.text)
    sys.exit(1)

# 2. Simulate callback (we ignore failure)
callback_url = f"{BACKEND}/auth/callback"
print(f"→ GET {callback_url}?code=dummy")
try:
    r2 = requests.get(callback_url, params={"code":"dummy"}, timeout=3)
    print("  callback status:", r2.status_code, "body:", r2.text)
except Exception as e:
    print("  callback failed (ignored):", e)

# 3. Connect to Anvil
w3 = Web3(Web3.HTTPProvider(ANVIL))
acct = Account.from_key(PRIVATE_KEY)
print("Using account", acct.address)

# 4. Instantiate factory contract
factory = w3.eth.contract(address=FACTORY_ADDRESS, abi=FACTORY_ABI)

# 5. Dummy proof inputs
a = [0, 0]
b = [[0, 0], [0, 0]]
c = [0, 0]
pubSignals = []

gas_price = w3.to_wei("1", "gwei")          # helper renamed
tx = factory.functions.mintWallet(a, b, c, pubSignals, acct.address).build_transaction(
    {"from": acct.address,
     "nonce": w3.eth.get_transaction_count(acct.address),
     "gas": 5_000_000,
     "gasPrice": gas_price}
)
signed  = acct.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed.raw_transaction)  # snake‑case
print("  tx hash", tx_hash.hex())
rcpt = w3.eth.wait_for_transaction_receipt(tx_hash)
print("  receipt status", rcpt.status)

# 7. Decode the WalletMinted event
events = factory.events.WalletMinted().process_receipt(rcpt)
if not events:
    print("❌ no WalletMinted event")
    sys.exit(1)

print("✅ new wallet =", events[0]["args"]["wallet"])

```

test/ElectionManagerClosed.t.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/ElectionManager.sol";

contract ElectionManagerClosedTest is Test {
    ElectionManager em;

    function setUp() public {
        em = new ElectionManager(IMACI(address(0)));
    }

    function testElectionClosedRevert() public {
        em.createElection(bytes32(uint256(0x42)));
        (, uint256 endBlock) = em.elections(0);

        // roll past the end
        vm.roll(endBlock + 1);

        vm.expectRevert("closed");
        em.enqueueMessage(1, 0, new bytes(0));
    }
}

```

test/FuzzAndInvariant.t.sol:
```
// test/FuzzAndInvariant.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/WalletFactory.sol";
import "../contracts/Verifier.sol";
import "../contracts/ElectionManager.sol";
import "@account-abstraction/contracts/core/EntryPoint.sol";

// --- Stub verifier that always passes ---
contract VerifierStub is Verifier {
    function verifyProof(
        uint256[2] memory,
        uint256[2][2] memory,
        uint256[2] memory,
        uint256[] memory
    ) external pure override returns (bool) {
        return true;
    }
}

// --- Fuzz tests ---
contract FuzzTests is Test {
    WalletFactory factory;
    ElectionManager em;
    VerifierStub vs;

    function setUp() public {
        vs = new VerifierStub();
        factory = new WalletFactory(EntryPoint(payable(address(0))), vs);
        em = new ElectionManager(IMACI(address(0)));
    }

    /// For any non‑zero caller+owner, mintWallet must return a non‑zero address
    function testFuzz_MintProducesWallet(address caller, address owner) public {
        vm.assume(caller != address(0) && owner != address(0));
        uint256[2] memory a;
        uint256[2][2] memory b;
        uint256[2] memory c;
        uint256[] memory inputs;
        vm.prank(caller);
        address wallet = factory.mintWallet(a, b, c, inputs, owner);
        assertTrue(wallet != address(0));
        assertEq(factory.walletOf(caller), wallet);
    }

    /// After a successful mint, a second mint must revert
    function testFuzz_DuplicateMintReverts(
        address caller,
        address owner
    ) public {
        vm.assume(caller != address(0) && owner != address(0));
        uint256[2] memory a;
        uint256[2][2] memory b;
        uint256[2] memory c;
        uint256[] memory inputs;
        vm.prank(caller);
        factory.mintWallet(a, b, c, inputs, owner);

        vm.prank(caller);
        vm.expectRevert(bytes("Factory: already minted"));
        factory.mintWallet(a, b, c, inputs, owner);
    }

    /// If you roll past `end`, enqueueMessage must revert with "closed"
    function testFuzz_ElectionClosed(uint256 offset) public {
        vm.assume(offset > 0 && offset < 10_000);
        em.createElection(bytes32(uint256(0x42)));
        (, uint256 endBlock) = em.elections(0);
        vm.roll(endBlock + offset);
        vm.expectRevert("closed");
        em.enqueueMessage(1, 0, new bytes(0));
    }
}

// --- Invariant tests ---
contract InvariantTests is Test {
    ElectionManager em;

    function setUp() public {
        em = new ElectionManager(IMACI(address(0)));
        targetContract(address(em));
    }

    /// For every created election, start ≤ end must always hold
    function invariant_startBeforeOrAtEnd() public view {
        uint256 n = em.nextId();
        for (uint256 i = 0; i < n; i++) {
            (uint256 s, uint256 e) = em.elections(i);
            assertLe(s, e);
        }
    }
}

```

test/SmartWalletSig.t.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/SmartWallet.sol";
import "@account-abstraction/contracts/core/EntryPoint.sol";

/// @dev Expose the internal _isValidSignature for testing
contract SigHelper is SmartWallet {
    constructor(IEntryPoint ep, address owner_) SmartWallet(ep, owner_) {}

    function isValid(
        bytes32 hash,
        bytes calldata signature
    ) external view returns (bool) {
        return _isValidSignature(hash, signature);
    }
}

contract SmartWalletSigTest is Test {
    SigHelper wallet;
    uint256 constant OWNER_KEY = 0xA11CE;
    address ownerAddr;

    function setUp() public {
        ownerAddr = vm.addr(OWNER_KEY);
        wallet = new SigHelper(EntryPoint(payable(address(0))), ownerAddr);
    }

    function testValidSignature() public {
        bytes32 msgHash = keccak256("dummy userOp");
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(OWNER_KEY, msgHash);
        bytes memory sig = abi.encode(v, r, s);
        bool ok = wallet.isValid(msgHash, sig);
        assertTrue(ok, "correct key should validate");
    }

    function testInvalidSignature() public {
        bytes32 msgHash = keccak256("dummy userOp");
        (uint8 v, bytes32 r, bytes32 s) = vm.sign(0xBEEF, msgHash);
        bytes memory sig = abi.encode(v, r, s);
        bool ok = wallet.isValid(msgHash, sig);
        assertFalse(ok, "wrong key should fail");
    }
}

```

test/SmokeTests.t.sol:
```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/Verifier.sol";
import "../contracts/WalletFactory.sol";
import "../contracts/ElectionManager.sol";
import "@account-abstraction/contracts/core/EntryPoint.sol";

// -------------------- stub contracts --------------------

contract VerifierStub is Verifier {
    function verifyProof(
        uint256[2] memory,
        uint256[2][2] memory,
        uint256[2] memory,
        uint256[] memory
    ) external pure override returns (bool) {
        return true;
    }
}

contract MACIStub is IMACI {
    event MessagePublished(bytes data);
    function publishMessage(bytes calldata m) external override {
        emit MessagePublished(m);
    }
}

// -------------------- tests -----------------------------

contract SmokeTests is Test {
    WalletFactory factory;
    VerifierStub verifier;
    ElectionManager em;
    MACIStub maci;
    address immutable alice = address(0xBEEF);

    function setUp() public {
        verifier = new VerifierStub();
        // zero EntryPoint address is fine for these unit tests
        factory = new WalletFactory(EntryPoint(payable(address(0))), verifier);
        maci = new MACIStub();
        em = new ElectionManager(IMACI(maci));
    }

    function testMintAndDupRevert() public {
        uint256[2] memory a;
        uint256[2][2] memory b;
        uint256[2] memory c;
        uint256[] memory inputs;

        vm.prank(alice);
        factory.mintWallet(a, b, c, inputs, alice);

        vm.prank(alice);
        vm.expectRevert(bytes("Factory: already minted"));
        factory.mintWallet(a, b, c, inputs, alice);
    }

    function testElectionCreateAndEnqueue() public {
        em.createElection(bytes32(uint256(0x42)));
        vm.roll(block.number + 1);
        em.enqueueMessage(1, 0, new bytes(0));
    }
}

```

test/WalletFactoryDeterminism.t.sol:
```
// test/WalletFactoryDeterminism.t.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../contracts/WalletFactory.sol";
import "../contracts/SmartWallet.sol";
import "../contracts/Verifier.sol";
import "@account-abstraction/contracts/core/EntryPoint.sol";

// stub verifier which always returns true
contract VerifierStub is Verifier {
    function verifyProof(
        uint256[2] memory,
        uint256[2][2] memory,
        uint256[2] memory,
        uint256[] memory
    ) external pure override returns (bool) {
        return true;
    }
}

contract WalletFactoryDeterminismTest is Test {
    EntryPoint ep;
    WalletFactory factory;
    address alice = address(0xABCD);
    address owner = address(0x1234);

    function setUp() public {
        ep = EntryPoint(payable(address(0)));
        factory = new WalletFactory(ep, new VerifierStub());
    }

    function testCreate2AddressDeterminism() public {
        uint256[2] memory a = [uint256(0), uint256(0)];
        uint256[2][2] memory b = [
            [uint256(0), uint256(0)],
            [uint256(0), uint256(0)]
        ];
        uint256[2] memory c = [uint256(0), uint256(0)];
        uint256[] memory inputs;

        vm.prank(alice);
        address wallet = factory.mintWallet(a, b, c, inputs, owner);

        // recompute CREATE2 address
        bytes32 salt = keccak256(abi.encodePacked(owner, alice));
        bytes memory creation = abi.encodePacked(
            type(SmartWallet).creationCode,
            abi.encode(ep, owner)
        );
        bytes32 codeHash = keccak256(creation);
        address expected = address(
            uint160(
                uint256(
                    keccak256(
                        abi.encodePacked(
                            bytes1(0xff),
                            address(factory),
                            salt,
                            codeHash
                        )
                    )
                )
            )
        );

        assertEq(wallet, expected, "mintWallet wrong");
        assertEq(factory.walletOf(alice), expected, "walletOf wrong");
    }
}

```

